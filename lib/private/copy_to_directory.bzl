"copy_to_directory implementation"

load("@bazel_skylib//lib:paths.bzl", skylib_paths = "paths")
load(":copy_common.bzl", _COPY_EXECUTION_REQUIREMENTS = "COPY_EXECUTION_REQUIREMENTS")
load(":paths.bzl", "paths")
load(":directory_path.bzl", "DirectoryPathInfo")

_copy_to_directory_attr = {
    "srcs": attr.label_list(allow_files = True),
    "root_paths": attr.string_list(default = []),
    "include_external_repositories": attr.string_list(default = []),
    "exclude_prefixes": attr.string_list(default = []),
    "replace_prefixes": attr.string_dict(default = {}),
    "is_windows": attr.bool(mandatory = True),
}

def _longest_match(subject, tests, allow_partial = False):
    match = None
    high_score = 0
    for test in tests:
        starts_with_test = test if allow_partial else test + "/"
        if subject == test or subject.startswith(starts_with_test):
            score = len(test)
            if score > high_score:
                match = test
                high_score = score
    return match

# src can either be a File or a target with a DirectoryPathInfo
def _copy_paths(ctx, src):
    if type(src) == "File":
        src_file = src
        src_path = src_file.path
        output_path = paths.to_workspace_path(src_file)
    elif DirectoryPathInfo in src:
        src_file = src[DirectoryPathInfo].directory
        src_path = "/".join([src_file.path, src[DirectoryPathInfo].path])
        output_path = "/".join([paths.to_workspace_path(src_file), src[DirectoryPathInfo].path])
    else:
        fail("Unsupported type")

    # if the file is from an external repository check if that repository should
    # be included in the output directory
    if src_file.owner and src_file.owner.workspace_name and not src_file.owner.workspace_name in ctx.attr.include_external_repositories:
        return None, None, None

    # strip root paths
    root_path = _longest_match(output_path, ctx.attr.root_paths)
    if root_path:
        strip_depth = len(root_path.split("/"))
        output_path = "/".join(output_path.split("/")[strip_depth:])

    # check if this file matches an exclude_prefix
    match = _longest_match(output_path, ctx.attr.exclude_prefixes, True)
    if match:
        # file is excluded due to match in exclude_prefix
        return None, None, None

    # apply a replacement if one is found
    match = _longest_match(output_path, ctx.attr.replace_prefixes.keys(), True)
    if match:
        output_path = ctx.attr.replace_prefixes[match] + output_path[len(match):]

    return src_path, output_path, src_file

def _copy_to_dir_bash(ctx, copy_paths, dst_dir):
    cmds = [
        "set -o errexit -o nounset -o pipefail",
        "mkdir -p \"%s\"" % dst_dir.path,
    ]

    inputs = []

    for src_path, dst_path, src_file in copy_paths:
        inputs.append(src_file)

        cmds.append("""
if [[ ! -e "{src}" ]]; then echo "file '{src}' does not exist"; exit 1; fi
if [[ -f "{src}" ]]; then
    mkdir -p "{dst_dir}"
    cp -f "{src}" "{dst}"
else
    mkdir -p "{dst}"
    cp -fR "{src}"/* "{dst}"
fi
""".format(src = src_path, dst_dir = skylib_paths.dirname(dst_path), dst = dst_path))

    ctx.actions.run_shell(
        inputs = inputs,
        outputs = [dst_dir],
        command = "\n".join(cmds),
        mnemonic = "CopyToDirectory",
        progress_message = "Copying files to directory",
        use_default_shell_env = True,
        execution_requirements = _COPY_EXECUTION_REQUIREMENTS,
    )

def _copy_to_dir_cmd(ctx, copy_paths, dst_dir):
    # Most Windows binaries built with MSVC use a certain argument quoting
    # scheme. Bazel uses that scheme too to quote arguments. However,
    # cmd.exe uses different semantics, so Bazel's quoting is wrong here.
    # To fix that we write the command to a .bat file so no command line
    # quoting or escaping is required.
    # Based on skylib copy_file:
    # https://github.com/bazelbuild/bazel-skylib/blob/main/rules/private/copy_file_private.bzl#L28.
    bat = ctx.actions.declare_file(ctx.label.name + "-cmd.bat")

    # NB: mkdir will create all subdirectories; it will exit 1
    # print an error to stderr if the directory already exists so
    # we supress both its stdout & stderr output
    cmds = ["""
@rem Generated by copy_to_directory.bzl, do not edit.
@echo off
mkdir "%s" >NUL 2>NUL
""" % dst_dir.path.replace("/", "\\")]

    inputs = []

    for src_path, dst_path, src_file in copy_paths:
        inputs.append(src_file)

        # copy & xcopy flags are documented at
        # https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/copy
        # https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy
        cmds.append("""
if not exist "{src}" (
    echo file "{src}" does not exist
    exit /b 1
)
if exist "{src}\\*" (
    mkdir "{dst}" >NUL 2>NUL
    robocopy "{src}" "{dst}" /E >NUL
) else (
    mkdir "{dst_dir}" >NUL 2>NUL
    copy /Y "{src}" "{dst}" >NUL
)
""".format(
            src = src_path.replace("/", "\\"),
            dst_dir = skylib_paths.dirname(dst_path).replace("/", "\\"),
            dst = dst_path.replace("/", "\\"),
        ))

    # robocopy return non-zero exit codes on success so we must exit 0 when we are done
    cmds.append("exit 0")

    ctx.actions.write(
        output = bat,
        # Do not use lib/shell.bzl's shell.quote() method, because that uses
        # Bash quoting syntax, which is different from cmd.exe's syntax.
        content = "\n".join(cmds),
        is_executable = True,
    )

    ctx.actions.run(
        inputs = inputs,
        tools = [bat],
        outputs = [dst_dir],
        executable = "cmd.exe",
        arguments = ["/C", bat.path.replace("/", "\\")],
        mnemonic = "CopyToDirectory",
        progress_message = "Copying files to directory",
        use_default_shell_env = True,
    )

def _copy_to_directory_impl(ctx):
    if not ctx.attr.srcs:
        msg = "srcs must not be empty in copy_to_directory %s" % ctx.label
        fail(msg)

    output = ctx.actions.declare_directory(ctx.attr.name)

    # Gather a list of src_path, dst_path pairs
    copy_paths = []
    for src in ctx.attr.srcs:
        if DirectoryPathInfo in src:
            src_path, output_path, src_file = _copy_paths(ctx, src)
            if src_path != None:
                dst_path = skylib_paths.normalize("/".join([output.path, output_path]))
                copy_paths.append((src_path, dst_path, src_file))
    for src_file in ctx.files.srcs:
        src_path, output_path, src_file = _copy_paths(ctx, src_file)
        if src_path != None:
            dst_path = skylib_paths.normalize("/".join([output.path, output_path]))
            copy_paths.append((src_path, dst_path, src_file))

    if ctx.attr.is_windows:
        _copy_to_dir_cmd(ctx, copy_paths, output)
    else:
        _copy_to_dir_bash(ctx, copy_paths, output)
    return [
        DefaultInfo(
            files = depset([output]),
            runfiles = ctx.runfiles([output]),
        ),
    ]

copy_to_directory_lib = struct(
    attrs = _copy_to_directory_attr,
    impl = _copy_to_directory_impl,
    provides = [DefaultInfo],
)
