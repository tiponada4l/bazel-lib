"write_source_file implementation"

load("//lib:utils.bzl", "is_external_label")
load(":directory_path.bzl", "DirectoryPathInfo")

_write_source_file_attrs = {
    "in_file": attr.label(allow_files = True, mandatory = False),
    "out_file": attr.label(allow_files = True, mandatory = False),
    "additional_update_targets": attr.label_list(cfg = "host", mandatory = False),
    "is_windows": attr.bool(mandatory = True),
}

def _write_source_file_sh(ctx, paths):
    updater = ctx.actions.declare_file(
        ctx.label.name + "_update.sh",
    )

    additional_update_scripts = []
    for target in ctx.attr.additional_update_targets:
        if target[DefaultInfo].files_to_run and target[DefaultInfo].files_to_run.executable:
            additional_update_scripts.append(target[DefaultInfo].files_to_run.executable)
        else:
            fail("additional_update_targets target %s does not provide an executable")

    contents = ["""#!/usr/bin/env bash
set -o errexit -o nounset -o pipefail
runfiles_dir=$PWD
# BUILD_WORKSPACE_DIRECTORY not set when running as a test, uses the sandbox instead
if [[ ! -z "${BUILD_WORKSPACE_DIRECTORY:-}" ]]; then
    cd "$BUILD_WORKSPACE_DIRECTORY"
fi"""]

    for in_path, out_path in paths:
        contents.append("""
in=$runfiles_dir/{in_path}
out={out_path}

mkdir -p "$(dirname "$out")"
echo "Copying $in to $out in $PWD"

if [[ -f "$in" ]]; then
    cp -f "$in" "$out"
    chmod 664 "$out"
else
    mkdir -p "$out"
    cp -rf "$in"/* "$out"
    chmod 664 "$out"/*
fi
""".format(in_path = in_path, out_path = out_path))

    contents.extend([
        "cd \"$runfiles_dir\"",
        "# Run the update scripts for all write_source_file deps",
    ])
    for update_script in additional_update_scripts:
        contents.append("\"{update_script}\"".format(update_script = update_script.short_path))

    ctx.actions.write(
        output = updater,
        is_executable = True,
        content = "\n".join(contents),
    )

    return updater

def _write_source_file_bat(ctx, paths):
    updater = ctx.actions.declare_file(
        ctx.label.name + "_update.bat",
    )

    additional_update_scripts = []
    for target in ctx.attr.additional_update_targets:
        if target[DefaultInfo].files_to_run and target[DefaultInfo].files_to_run.executable:
            additional_update_scripts.append(target[DefaultInfo].files_to_run.executable)
        else:
            fail("additional_update_targets target %s does not provide an executable")

    contents = ["""@rem Generated by write_source_file.bzl, do not edit.
@echo off
set runfiles_dir=%cd%
if defined BUILD_WORKSPACE_DIRECTORY (
    cd %BUILD_WORKSPACE_DIRECTORY%
)"""]

    for in_path, out_path in paths:
        contents.append("""
set in=%runfiles_dir%\\{in_path}
set out={out_path}

if not defined BUILD_WORKSPACE_DIRECTORY (
    @rem Because there's no sandboxing in windows, if we copy over the target
    @rem file's symlink it will get copied back into the source directory
    @rem during tests. Work around this in tests by deleting the target file
    @rem symlink before copying over it.
    del %out%
)

echo Copying %in% to %out% in %cd%

if exist "%in%\\*" (
    mkdir "%out%" >NUL 2>NUL
    robocopy "%in%" "%out%" /E >NUL
) else (
    copy %in% %out% >NUL
)
""".format(in_path = in_path.replace("/", "\\"), out_path = out_path.replace("/", "\\")))

    contents.extend([
        "cd %runfiles_dir%",
        "@rem Run the update scripts for all write_source_file deps",
    ])
    for update_script in additional_update_scripts:
        contents.append("call {update_script".format(update_script = update_script.short_path))

    ctx.actions.write(
        output = updater,
        is_executable = True,
        context = "\n".join(contents).replace("\n", "\r\n"),
    )
    return updater

def _write_source_file_impl(ctx):
    if ctx.attr.out_file:
        if not ctx.attr.in_file:
            fail("in_file must be specified if out_file is set")
        if is_external_label(ctx.attr.out_file.label):
            fail("out file %s must be in the user workspace" % ctx.attr.out_file.label)
        if ctx.attr.out_file.label.package != ctx.label.package:
            fail("out file %s (in package '%s') must be a source file within the target's package: '%s'" % (ctx.attr.out_file.label, ctx.attr.out_file.label.package, ctx.label.package))

    if ctx.attr.in_file and not ctx.attr.out_file:
        if not ctx.attr.in_file:
            fail("out_file must be specified if in_file is set")

    paths = []
    runfiles = []

    if ctx.attr.in_file and ctx.attr.out_file:
        if DirectoryPathInfo in ctx.attr.in_file:
            in_path = "/".join([
                ctx.attr.in_file[DirectoryPathInfo].directory.short_path,
                ctx.attr.in_file[DirectoryPathInfo].path,
            ])
            runfiles.append(ctx.attr.in_file[DirectoryPathInfo].directory)
        elif len(ctx.files.in_file) == 0:
            fail("in file %s must provide files" % ctx.attr.in_file.label)
        elif len(ctx.files.in_file) == 1:
            in_path = ctx.files.in_file[0].short_path
        else:
            fail("in file %s must be a single file or a target that provides DefaultOutputPathInfo or DirectoryPathInfo" % ctx.attr.in_file.label)

        if len(ctx.files.out_file) != 1:
            fail("out file %s must be a single file or directory" % ctx.attr.out_file.label)
        elif not ctx.files.out_file[0].is_source:
            fail("out file %s must be a source file or directory, not a generated file" % ctx.attr.out_file.label)

        out_path = ctx.files.out_file[0].short_path
        paths.append((in_path, out_path))

    if ctx.attr.is_windows:
        updater = _write_source_file_bat(ctx, paths)
    else:
        updater = _write_source_file_sh(ctx, paths)

    runfiles = ctx.runfiles(
        files = runfiles,
        transitive_files = ctx.attr.in_file.files if ctx.attr.in_file else None,
    )
    deps_runfiles = [dep[DefaultInfo].default_runfiles for dep in ctx.attr.additional_update_targets]
    if "merge_all" in dir(runfiles):
        runfiles = runfiles.merge_all(deps_runfiles)
    else:
        for dep in deps_runfiles:
            runfiles = runfiles.merge(dep)

    return [
        DefaultInfo(
            executable = updater,
            runfiles = runfiles,
        ),
    ]

write_source_file_lib = struct(
    attrs = _write_source_file_attrs,
    implementation = _write_source_file_impl,
)
